[{"content":"文档\nFFmpeg 介绍 ffmpeg 是一款通用的媒体转换器。它能读取各种输入（包括实时抓取/录制设备），并将其过滤和转码为大量输出格式。\n转码程序工作图 muxer：即多路复用器，主要用于将音频流、视频流、字幕流等不同的数据流进行混合，生成一个包含所有信息的单一数据流。如mp4等格式 demuxer：对视频进行解封装 工具 ffmpeg：主程序 ffplay：简单的音视频查看工具 ffprobe：查看音视频信息工具 示例 查看文件信息：ffmpeg -i demo.mp4或ffprobe demo.mp4，添加-hide_banner可以隐藏版本，配置参数等信息 转换文件格式：ffmpeg -i demo.mp4 demo.mov 获取一张视频截图：ffmpeg -i demo.mp4 -ss 00:00:01 -f image2 -vframes 1 out.jpg 视频添加水印：`ffmpeg -i demo.mp4 -i logo.png -filter_complex \u0026ldquo;overlay=x:y out.mp4\u0026rdquo; 视频去除水印：ffmpeg -i demo.mp4 -vf \u0026quot;delogo=x=xxx:y=xxx:w=xxx:h=xxx:show=0\u0026quot; -c:a copy out.mp4 更改视频分辨率：ffmpeg -i demo.mp4 -vf scale=-1:720 删除视频中的音频：ffmpeg -i demo.mp4 -an out.mp4 视频转gif图：ffmpeg -i demo.mp4 -ss 00:00:30 -t3 -vf \u0026quot;fps=24,scale=600:-1:flags=lanczos,split[s0][s1];[s0]palettegen[p];[s1][p]paletteuse\u0026quot; test.gif 参考 知乎：FFMPEG详解(完整版）\nB站：FFmpeg 速成教学\n视频转gif图\n","permalink":"http://yysog.com/posts/ffmpeg%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","summary":"\u003cp\u003e\u003ca href=\"https://ffmpeg.org/ffmpeg.html\"\u003e文档\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"ffmpeg\"\u003eFFmpeg\u003c/h1\u003e\n\u003ch2 id=\"介绍\"\u003e介绍\u003c/h2\u003e\n\u003cp\u003effmpeg 是一款通用的媒体转换器。它能读取各种输入（包括实时抓取/录制设备），并将其过滤和转码为大量输出格式。\u003c/p\u003e\n\u003ch2 id=\"转码程序工作图\"\u003e转码程序工作图\u003c/h2\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"../../img/posts/image-20240519170946267.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003emuxer：即多路复用器，主要用于将音频流、视频流、字幕流等不同的数据流进行混合，生成一个包含所有信息的单一数据流。如mp4等格式\u003c/li\u003e\n\u003cli\u003edemuxer：对视频进行解封装\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"工具\"\u003e工具\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003effmpeg：主程序\u003c/li\u003e\n\u003cli\u003effplay：简单的音视频查看工具\u003c/li\u003e\n\u003cli\u003effprobe：查看音视频信息工具\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"示例\"\u003e示例\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e查看文件信息：\u003ccode\u003effmpeg -i demo.mp4\u003c/code\u003e或\u003ccode\u003effprobe demo.mp4\u003c/code\u003e，添加\u003ccode\u003e-hide_banner\u003c/code\u003e可以隐藏版本，配置参数等信息\u003c/li\u003e\n\u003cli\u003e转换文件格式：\u003ccode\u003effmpeg -i demo.mp4 demo.mov\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e获取一张视频截图：\u003ccode\u003effmpeg -i demo.mp4 -ss 00:00:01 -f image2 -vframes 1 out.jpg\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e视频添加水印：`ffmpeg -i demo.mp4 -i logo.png -filter_complex \u0026ldquo;overlay=x:y out.mp4\u0026rdquo;\u003c/li\u003e\n\u003cli\u003e视频去除水印：\u003ccode\u003effmpeg -i demo.mp4 -vf \u0026quot;delogo=x=xxx:y=xxx:w=xxx:h=xxx:show=0\u0026quot; -c:a copy out.mp4\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e更改视频分辨率：\u003ccode\u003effmpeg -i demo.mp4 -vf scale=-1:720\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e删除视频中的音频：\u003ccode\u003effmpeg -i demo.mp4 -an out.mp4\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e视频转gif图：\u003ccode\u003effmpeg -i demo.mp4 -ss 00:00:30 -t3 -vf \u0026quot;fps=24,scale=600:-1:flags=lanczos,split[s0][s1];[s0]palettegen[p];[s1][p]paletteuse\u0026quot; test.gif\u003c/code\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"参考\"\u003e参考\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://zhuanlan.zhihu.com/p/673522888\"\u003e知乎：FFMPEG详解(完整版）\u003c/a\u003e\u003cbr\u003e\n\u003ca href=\"https://www.bilibili.com/video/BV1bu4y1n78A/\"\u003eB站：FFmpeg 速成教学\u003c/a\u003e\u003cbr\u003e\n\u003ca href=\"https://blog.csdn.net/qq284489030/article/details/134683655\"\u003e视频转gif图\u003c/a\u003e\u003c/p\u003e","title":"FFmpeg的基本使用"},{"content":"在 Arch Linux 中将多网口主机配置为交换机可以通过创建一个网桥来实现\n步骤 1：安装必要的工具 确保系统上已安装 bridge-utils，通常情况下它默认包含在 Arch Linux 中。如果没有，可以使用以下命令安装它：\nsudo pacman -S bridge-utils 步骤 2：创建网桥 编辑网络配置文件：在 Arch Linux 中，可以使用 systemd 的网络配置方法或 netctl。这里我们将使用 systemd-networkd。\n创建网桥配置文件，例如 /etc/systemd/network/10-br0.netdev： [NetDev] Name=br0 Kind=bridge 添加物理接口到网桥：例如，假设有两个接口：eth0 和 eth1。需要分别为这些接口创建配置文件，例如：\n/etc/systemd/network/20-eth0.network： [Match] Name=eth0 [Network] Bridge=br0 /etc/systemd/network/20-eth1.network： [Match] Name=eth1 [Network] Bridge=br0 配置网桥的IP地址：如果网桥需要获取一个静态IP地址，可以创建另一个配置文件，例如 /etc/systemd/network/30-br0.network：\n[Match] Name=br0 [Network] Address=192.168.1.100/24 # 请根据的网络环境调整 Gateway=192.168.1.1 DNS=8.8.8.8 如果想要使用 DHCP，可以设置：\n[Match] Name=br0 [Network] DHCP=yes 步骤 3：启用并启动 systemd-networkd 启用 systemd-networkd 服务：\nsudo systemctl enable systemd-networkd sudo systemctl start systemd-networkd 启用和启动 systemd-resolved 服务（如果使用 DNS）：\nsudo systemctl enable systemd-resolved sudo systemctl start systemd-resolved 步骤 4：检查配置 使用以下命令检查网桥和接口的状态，验证配置是否正确：\nip addr show brctl show 步骤 5：连接和测试 将需要通过网桥通讯的设备接入 eth0 和 eth1，并确保设备能够正常工作。\n验证另一台计算机是否能够从连接到 eth0 或 eth1 的接口获取到 IP 地址，确保流量可以正常通过网桥。\n注意检查iptables确保br0的流量没有被拦截，如docker会有一条默认的规则导致无法正常访问，可能将下面规则添加到/etc/iptables/iptalbes.rules\n-A FORWARD -i br0 -j ACCEPT\n然后启动iptables.service\nsudo systemctl enable --now iptables.service ","permalink":"http://yysog.com/posts/linux%E7%BD%91%E6%A1%A5%E9%85%8D%E7%BD%AE/","summary":"\u003cp\u003e在 Arch Linux 中将多网口主机配置为交换机可以通过创建一个网桥来实现\u003c/p\u003e\n\u003ch3 id=\"步骤-1安装必要的工具\"\u003e步骤 1：安装必要的工具\u003c/h3\u003e\n\u003cp\u003e确保系统上已安装 \u003ccode\u003ebridge-utils\u003c/code\u003e，通常情况下它默认包含在 Arch Linux 中。如果没有，可以使用以下命令安装它：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo pacman -S bridge-utils\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"步骤-2创建网桥\"\u003e步骤 2：创建网桥\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e编辑网络配置文件\u003c/strong\u003e：在 Arch Linux 中，可以使用 \u003ccode\u003esystemd\u003c/code\u003e 的网络配置方法或 \u003ccode\u003enetctl\u003c/code\u003e。这里我们将使用 \u003ccode\u003esystemd-networkd\u003c/code\u003e。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e创建网桥配置文件，例如 \u003ccode\u003e/etc/systemd/network/10-br0.netdev\u003c/code\u003e：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-init\" data-lang=\"init\"\u003e[NetDev]\nName=br0\nKind=bridge\n\u003c/code\u003e\u003c/pre\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e添加物理接口到网桥\u003c/strong\u003e：例如，假设有两个接口：\u003ccode\u003eeth0\u003c/code\u003e 和 \u003ccode\u003eeth1\u003c/code\u003e。需要分别为这些接口创建配置文件，例如：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e/etc/systemd/network/20-eth0.network\u003c/code\u003e：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-init\" data-lang=\"init\"\u003e[Match]\nName=eth0\n\n[Network]\nBridge=br0\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e/etc/systemd/network/20-eth1.network\u003c/code\u003e：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-init\" data-lang=\"init\"\u003e[Match]\nName=eth1\n\n[Network]\nBridge=br0\n\u003c/code\u003e\u003c/pre\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e配置网桥的IP地址\u003c/strong\u003e：如果网桥需要获取一个静态IP地址，可以创建另一个配置文件，例如 \u003ccode\u003e/etc/systemd/network/30-br0.network\u003c/code\u003e：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-init\" data-lang=\"init\"\u003e[Match]\nName=br0\n\n[Network]\nAddress=192.168.1.100/24  # 请根据的网络环境调整\nGateway=192.168.1.1\nDNS=8.8.8.8\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e如果想要使用 DHCP，可以设置：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-init\" data-lang=\"init\"\u003e[Match]\nName=br0\n\n[Network]\nDHCP=yes\n\u003c/code\u003e\u003c/pre\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"步骤-3启用并启动-systemd-networkd\"\u003e步骤 3：启用并启动 \u003ccode\u003esystemd-networkd\u003c/code\u003e\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e启用 \u003ccode\u003esystemd-networkd\u003c/code\u003e 服务：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo systemctl \u003cspan class=\"nb\"\u003eenable\u003c/span\u003e systemd-networkd\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo systemctl start systemd-networkd\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e启用和启动 \u003ccode\u003esystemd-resolved\u003c/code\u003e 服务（如果使用 DNS）：\u003c/p\u003e","title":"linux通过网桥将多网口主机当交换机"},{"content":"linux笔记 Linux 教程 | 菜鸟教程 (runoob.com)\n1. 字符/图形界面 1. 字符/图形界面的切换 计算机启动后默认进入图形界面登陆，若在进入字符界面，在图形登录界面使用Ctrl+Alt+F3;\n若需从字符界面返回图形界面，使用Ctrl+Alt+F1\n2. 查看/修改默认登陆界面 查看默认登陆界面：systemctl get-default\n修改默认登陆界面：sudo systemctl set-default [登陆状态]\n登陆状态：\ngraphical.target 表示图形界面 multi-user.target 表示字符界面 3. 字符界面关闭和重启(需要root权限) 1. shutdown 命令格式：shutdown [选项] [时间] [警告信息]\n最常用： $ sudo shutdown(一分钟后关机)\n选项 选项含义 -k 并不会关机，只发出警告信息给所有用户 -r 重新启动系统 -h 关闭系统 -c 取消运行shutdown 例：\n发出关机警告信息，并不会关机：$sudo shutdown -k 立即关机：$sudo shutdown –h now 45分钟后关闭计算机：$sudo shutdown –h +45 重启计算机并发出警告：$sudo shutdown –r now \u0026quot;system will be reboot now.\u0026quot; 定时在1点38分重启计算机：$sudo shutdown –r 01:38 2. halt 命令格式：halt [选项]\n最常用：$ sudo halt\n选项 选项含义 -w 并不会关机，将关机信息写入到/var/log/wtmp文件中 -d 关闭系统，不把记录写到/var/log/wtmp日志文件中 -f 不调用shutdown而强制关闭系统 3. reboot 命令格式：reboot [选项]\n最常用： $ sudo reboot\n选项 选项含义 -w 并不会真正重启系统，将重启信息写入到/var/log/wtmp文件中 -d 重启系统，不把记录写到/var/log/wtmp日志文件中 -f 不调用shutdown而强制重启系统 2. 字符界面下的命令 1. 命令排列 \u0026ldquo;;\u0026rdquo;\n命令1; 命令2\n不管命令1是否出错，都会执行命令2\n\u0026ldquo;\u0026amp;\u0026amp;\u0026rdquo;\n命令1 \u0026amp;\u0026amp; 命令2\n只有当命令1 正确运行完毕后，才执行命令2\n\u0026ldquo;||\u0026rdquo;\n命令1 || 命令2\n命令1 正确运行，不执行命令2；命令1运行错误，执行命令2\n2. 命令替换 \u0026ldquo;$()\u0026rdquo;\n命令1 $(命令2)。如：kill $(pidof less)\n\u0026ldquo;` `\u0026rdquo;\n命令1 `命令2`。 如：kill `pidof less`\n3. 命令别名 创建别名：alias [别名] = [需要定义别名的命令]\n取消别名：unalias [别名]\n注：如果命令中有空格的话，就需要使用双引号（比如在命令与选项之间就有空格）\n例：\n设置别名：\nalias work=\u0026quot;cd /home/user01/program/cplus\u0026quot;\n取消别名：\nunalias work\n3. 字符界面下的软件管理 1. dpkg(Debian Package):最早是Deb包管理工具 用法：dpkg [选项] 参数\n选项 含义 -i 安装软件(install) -R 安装一个目录下面所有的软件包(Regressive) -r 删除软件包，但保存其配置信息(remove) -L 查看软件安装文件所在位置(Location) 2. apt-get 命令 含义 apt-get install 安装包 apt-get reinstall 重新安装包 apt-get -f install 修复安装 apt-get remove 删除包 apt-get autoremove 删除包及其依赖 apt-get upgrade 更新已安装的包 4. 目录和文件 1. 更改工作目录：cd [目录] cd(change directory)命令的特殊用法：\ncd .. 转到当前目录的上层目录 cd ~ 转到当前用户的家目录 cd ../../ 转到当前目录的上上层目录 2. 显示当前工作目录：pwd 3. 目录与文件查看: ls 命令语法：ls [选项] [目录|文件](默认为当前目录)\n选项 含义 -l 以长格式形式显示 -a 显示所有文件或目录，包括隐藏文件 -i 显示文件索引信息，也就是文件的inode号 -d 只列出目录 4. 目录与文件创建：mkdir(目录)、touch(空文件)、cat(创建并写入) mkdir [选项] [目录]\n创建一个目录，常用选项:\n-m 指定所有用户对新建目录的权限\n-p 可以强制创建多层目录\n例：\n创建一个目录： $ mkdir a\n创建多人目录：$ mkdir a b c d\n创建目录时指定目录权限：$ mkdir -m 777 a\n强制创建目录：$ mkdir -p a/b/c\ntouch [选项] [文件]\n创建一个空文件\ncat \u0026gt; file\n从键盘写入，按Ctrl + c退出，直接 cat file可以查看文件内容\n5. 目录与文件复制：cp [选项] [源文件|目录] [目标文件|目录] 注：源文件/目录可以为多个文件/目录\n常用选项：\n-r：递归复制\n例：\n复制文件file1到/tmp中并重命名为file2：$ cp file1 /tmp/file2\n复制目录/tmp到目录/tmp/hadoop下：$ cp –r /tmp /home/hadoop\n6. 目录与文件移动：mv [选项] [源文件|目录] [目标文件|目录] 例：\n将文件file1重命名为file2: $ mv file1 file2\n将/tmp目录下的pic重命名为pic2: $ mv /tmp/pic /tmp/pic2\n将/tmp目录下的目录pic移动到/usr/local/share/pic：$ mv /tmp/pic /usr/local/share/pic\n7. 目录与文件删除：rm [选项] [文件|目录]、rmdir 目录名 rm [选项] [文件|目录]\n常用选项：\n-r: 递归删除，可以删除目录下的文件或目录\n-f: 删除文件时不提醒而强制删除\nrmdir 目录名\n注：只能删除空目录，若删除目录及其父目录使用rmdir -p a/b将先删除b目录，再删除a目录，前提是为空目录\n5. 文件或目录的权限 1. 文件的保护方式 用户分类：文件拥有者(user)、同组用户(group)、其他用户(others) 三种权限：读(r)、写(w)、执行(x) 2. 查看文件的权限：ls -l [文件名] 3.文件或目录的权限设定：chmod [who] [+|-|=] [mode] 文件|目录 or chmod 数值 文件|目录 字符设定法：\n语法：chmod [who] [+|-|=] [mode] 文件|目录名\n说明：\n[who]：可以是下面字符中的一个或它们的组合：\nu(user): 表示“用户”，即文件或目录的所有者 g(group): 表示“同组用户” o(others): 表示“其他用户” a(all): 表示“所有用户” [+|-|=]：'+'表示添加某个权限；'-'表示取消某个权限；'='表示赋予给定权限\n[mode]：r(可读)、w(可写)、x(可执行)\n例：\n所有用户增加执行权限：$ chmod a+x test1 文件属主(u)和同组用户(g)增加写(w)权限，其他用户(o)删除写(w)、执行权限(x)：\n$ chmod ug+w, o-wx test2\n注：中间用逗号隔开 把文件执行权限改为rwxrw-rw-：$ chmod u=rwx,g=rw,o=rw test4 数值设定法：\n语法：chmod 数值 文件|目录名\n数值：rwx(二进制)\n例：\n属主(u)读写(rw)权限，同组用户(g)和其他用户(o)读(r)权限：$ chmod 644 aaa 属主(u)读写执行(rwx)权限，同组用户(g)读执行(rx)权限，其他用户(o)没有权限：$ chmod 750 bbb 6. 内容显示：cat、more、less、head、tail 1. cat：一次打印文件内容 语法：cat [选项] 文件名\n选项：\n-n 显示出行号\n-A 显示文件中所有字符，包括隐藏字符(换行符、制表符)\n2. more: 分页显示文件内容 语法：more 文件名\n注： 读完文件再显示 按空格向下翻页 ctrl+f向下翻页 ctrl+b向上翻页 按q键退出所查看的文件 3. less：边读边显示，启动快，其余与more基本相同 4. head：查看文件头几行数据 语法：head [-n number] file\n-n: 后面接数字，代表显示文件几行，不给定参数表示默认输出前10行\n例：\n查看文件前15行：$ head -n 15 test\n5. tail：查看文件末尾数据(用法写head类似) 7. 通配符与管道命令 1. 通配符 通配符：用符号来匹配一个或多个字符 符号 功能 ? 代表任何单一字符 * 代表任何字符串 [字符组合] 在中括号中的字符都符合，譬如：[a-z]代表任意一个小写字母 [!字符组合] 不在中括号中的字符都符合，譬如：[!0-9]代表任意一个非数字字符 2. 管道 管道：用符号\u0026quot;|\u0026ldquo;来标识。用于连接两个命令，将前一个命令的输出结果作为后一个命令的输入\n命令语法：[命令1]|[命令2]|[命令3]\n例： 查看/etc目录下的文件，并将结果分页显示：$ ls /etc | more 查看系统中已安装软件中软件名包含字符\u0026rsquo;a\u0026rsquo;的所有软件，并分页显示：$ dpkg -l | grep a|more 8. 数据流重定向 1. 数据流 数据流是一组有顺序的、有起点和终点的字节集合\n数据流类别分为三种：标准输入(stdin)，标准输出(stdout)和标准错误输出(stderr)\n设备文件 说明 文件描述符 /dev/stdin 标准输入 0 /dev/stdout 标准输出 1 /dev/stderr 标准错误 2 2. 数据流重定向 参考\n1. 输出重定向 类型 符号 作用 标准输出/错误重定向 命令[2]\u0026gt;文件 以覆盖的方式，把命令的正确/错\n误输出结果输出到指定的文件 标准输出/错误重定向 命令 [2]\u0026raquo;文件 以追加的方式，把命令的正确/错误\n输出结果输出到指定的文件 正确和错误输出同时保存 命令\u0026gt;文件 2\u0026gt;\u0026amp;1\n命令 \u0026amp;\u0026gt;文件 以覆盖的文式，把正确和错误结果\n输出到同一个文件 正确和错误输出同时保存 命令\u0026raquo;文件 2\u0026gt;\u0026amp;1\n命令 \u0026amp;\u0026raquo;文件 以追加的方式，把正确和错误结\n果输出到同一个文件 例：\n查看计算机网上信息并将结果输出到文件right中：$ ifconfig \u0026gt;\u0026gt; right 命令运行正确时重定向到right，出错时重定向到error：$ ls -l /etca \u0026gt;right 2\u0026gt;error 将ls命令运行结果重定向到right_error中(追加)：$ ls -l /etc \u0026amp;\u0026gt;\u0026gt;right_error 2. 输入重定向 wc：$ wc [选项] [文件名]\n选项：\n-l: 统计行数\n-w: 统计单词数\n-c: 统计字节数\n例：\n统计文件test的行数、单词数及字节数：$ wc \u0026lt; test\n9. 文本处理 1. 文本排序：sort [选项] 文件名 命令格式：sort [选项] 文件名\n功能：对文件中的文本默认按字典序从小到大进行排序，并将结果显示出来\n选项：\n-n: 按数值大小排序\n-u: 对排序后相同的行只保留一行\n-r: 按逆序输出排序结果\n-d: 按字典顺序排序\n-f: 忽略字母大小写\n例：\n对文件file1以倒序形式排序并显示在屏幕上：\n$ sort -r file1 / $ cat file1 sort -r 对文件file1排序并删掉重复的行：$ sort -u file1\n对数值文件file2按数值从小到大进行排序：$ sort -n file2\n2. 文本去重：uniq [选项] 文件名 命令格式：uniq [选项] 文件名\n功能：使用uniq命令可以将排序后文件内的重复行数据从输出文件中删除(源文件内容不会变)\n选项：\n-d: 只显示重复行\n-u: 只显示不重复的行\n例：\n使用uniq命令对文件file1去重后输出：$ sort file1 | uniq\n查看文件file1中重复的数据内容：$ sort file1 | uniq -d\n查看文件file1中不重复的数据内容：$ sort file1 | uniq -u\n3. 文本查找：grep [选项] [字符串] 文件名 命令格式：grep [选项] [字符串] 文件名\n功能：查找文件里符合条件的字符串行\n选项：\n-c: 只显示匹配的行数\n-i: 忽略字母大小写\n-n: 输出时加行号\n-v: 反转查找\n例：\n在/etc/adduser.conf文件中，查找含有adduser字符的行：\n$ grep adduer /etc/adduer.conf\n在adduser.conf文件中，查找不含\u0026rsquo;#\u0026lsquo;的行并列出行号：\n$ grep -vn \u0026quot;#\u0026quot; /etc/adduser.conf\n4. 文本剪切：cut -f List -d Character 文件 命令格式：cut -f list -d Character 文件\n功能：从文件每行中选出指定的字节、字符或字段\n-f: 获取被定界符隔开后指定的字段列表，从1开始(field)\n-d: 指定分隔字符(delimiter)\n例：\n将PATH变量值取出，使用cut命令找出第五个路径：\n$ echo $PATH | cut -d ':' -f 5\n显示文件/etc/passwd中的用户登录名和用户名全称字段：\ncut -f 1,5 -d : /etc/passwd\n获取export命令输出信息的第12-20字符以后的内容：\n$ export | cut -c 12-20\n5. 文本比较：diff [选项] 文件1 文件2 命令格式：diff [选项] 文件1 文件2\n选项： -c: 以context模式显示比较的结果，相对normal -y: 以并列的方式显示文件的异同之处 -W: 与选项-y一起使用，指定列宽 10. 文件查找 1. find 命令格式：find 目录 寻找条件操作\n功能：在目录结构中搜索文件，并执行指定的操作\n寻找条件通常为：\n文件名称\n文件属性\n时间\n例：\n在/etc目录下，寻找以.conf结尾的文件：$ find /etc -name *.conf\n在当前目录下，查找属于user01用户的文件和目录：$ find . -user user01\n查找当前目录及其子目录下所有最近2天内更新过的文件：$ find . -ctime -20\n2. locate 命令格式：locate -n N 文件名\n功能：从例行工作(crontab)程序创建的数据库中查找文件\n选项：\n-n: 显示查找结果的个数 例：\n查找文件passwd所在位置：$ locate passwd\n查找文件passed所在位置(显示前三个)：$ locate passwd\n注：\n对于刚建立的文件，使用locate可以查找不到，因为后台数据库一天更新一次，若想立即搜索到，必须使用root权限运行updatedb命令更新数据库\n3. whereis 命令格式：whereis [可选项] 要查找的字符串\n功能：查找指定文件、命令和手册页的位置\n选项：\n-b: 只查找二进制文件\n-m: 只查找说明文件\n-s: 只查找源代码文件\n例：\n查找mkdir命令的所有信息：$ whereis mkdir\n查看mkdir命令的手册信息：$ whereis -m mkdir\n11. 压缩备份 1. gzip 命令格式：gzip [选项] 压缩/解压的文件名\n功能：对文件进行压缩和解压缩。压缩后，会自动在文件名后加上.gz扩展名，默认不保留原文件\n选项：\n-c: 将输出写到标准输出上，并保留原文件\n-d: 将压缩文件解压\n-r: 递归式地查找指定目录并压缩、解压缩\n例：\n用gzip命令将/home/lisi目录下的文件压缩：$ gzip /home/lisi/*\n用命令将/home/lisi目录下所有的.gz文件解压缩：$ gzip -d /home/lisi/* or $ gunzip /home/lisi/*\n2. bzip2 命令格式：bzip2 [选项] 文件名\n功能：对目录和文件进行压缩或解压缩，压缩文件默认扩展名为bz2\n选项：\n-d: 解压缩选项\n-v: 显示压缩或解压缩过程\n-f: 当文件重名时，进行覆盖\n例：\n使用bzip2命令压缩/home/lisi/目录下的文件：$ bzip2 /home/lisi/*\n使用bzip2命令解压缩/hmoe/list/目录下的文件：\n$ bzip2 -d /home/lisi/*\n3. tar 命令格式：tar [选项] 文件/目录名\n功能：将多个文件或目录打包成一个文件\n选项：\n-z: 用gzip命令进行压缩或解压缩\n-j: 通过bzip2进行压缩/解压缩\n-C: 指定解压缩目录\n-c: 创建新的备份文件，备份目录或文件时必选项\n-f: 对普通文件进行操作。这个选项通常是必选的\n-r: 向备份档文件追加文件\n-x: 从备份档文件中解压文件\n-t: 列出备份文档中所含的文件\n-v: 列出处理过程中的详细信息\n例：\n把/boot 目录下文件和子目录打包，打包文件名为usr.tar:\n$ tar -cvf usr.tar /boot\n把/boot目录下的文件和子目录打包，并用gzip算法进行压缩，文件名为usr.tar.gz:\n$ tar -zcvf usr.tar.gz /boot\n把usr.tar.gz这个打包文件还原并解压缩：\n$ tar -zxvf usr.tar.gz\n将usr.tar.bz2这个打包文件解压缩到/tmp\n$ tar -jxvf usr.tar.bz2 -C /tmp\n查看usr.tar备份文件的内容，并显示在显示器上\n$ tar -tvf usr.tar\n将文件/root/abc/d添加到usr.tar包里面去\n$ tar -rvf usr.tar /root/abc/d\n12. vi/vim编辑器(看文档) 1. vi/vim的三种模式 命令模式 插入模式 底线模式 转换图\n2. vi/vim的使用：vi/vim键盘图 vim命令速查 1. 进入vi编辑器 编辑一个文件\nvim file\n编辑多个文件\nvim file1 file2\n命令 说明 :n 编辑下一个文件 :N 编辑上一个文件 :rew 编辑第一个文件 2. 退出vi/vim 文件不存盘退出：:q!或:q\n注：!表示强制，下同 文件存盘退出：:wq!或:wq 文件另存为：:w otherfile 部分文件另存：:1,7 w otherfile 向文件中追加：10,12 w \u0026gt;\u0026gt; otherfile 3. 移动光标 上下左右单步移动：h(←), j(↓), k(↑), l(→)\n上下左右多步移动：n方向\n如：向上移动3行：3k\n逐单词移动\n操作 说明 w 将光标移动到下一个单词开头 b 将光标向前移动一个单词 e 将光标移动到单词的词尾 注：操作前也可以加数字表示多步操作。如：移动到后面的第3个单词开头：3w\n在某一行内移动\n操作 说明 示例 f+任意字母键 将光标移到文本中下一个所指定的字母 fy： 在行内向后查找并移到到y处 任意数字键+| 将光标移到数字键指定的字符位置(以1开头) `13 $ 将光标移动到当前行的行末 $: 移到到行末 ^ 将光标移到当前行的行首 ^: 移到到行首 在不同行上移动\n操作 说明 数字+G 将光标移动到数字对应行的行首，只输入G则移到到文件最后一行 :任意数字 将光标移到数字对应行的行首 :$ 将光标移到文件最后一行行首 - 将光标向上移动一行，与k相同 + 将光标向下移动一行，与j相同 在屏幕上移动\n操作 说明 M 将光标移动至当前屏幕中间 L 将光标移动至当前屏幕最下方 H 将光标移到至当前屏幕最上方 回到初始位置：''\n调整显示文本\n操作 说明 Ctrl+D 向下移动半屏文本内容 Ctrl+U 向上移动半屏文本内容 Ctrl+F 显示文件下一屏的文本内容 Ctrl+B 显示文件上一屏的文本内容 4. 文本添加(进入插入模式) 操作 说明 i/I 在光标当前位置左侧/行首插入文本 a/A 在光标当前位置右侧/行末插入文本 o/O 在光标当前位置下方/上方插入文本(会创建新的一行) 5. 文本查找与替换 查找\n操作 说明 /str 向下查找字符串str ?str 向上查找字符串str n 在前两个的基础上查找下一个 N 在前两个的基础上查找上一个 替换([查看键盘图](http://w -sog.xyz:8180/2022/05/25/91cab7cf54015.gif))\n操作 说明 r 对光标所在字符替换 R 对光标所在字符之后替换，直到按下Esc键结束 cw 删除光标后的单词，并进入插入模式 cc/S/C 删除当前行，并进入插入模式，详情查看键盘图 :s/word1/word2 将全文word1替换成word2 cf(ch) c和f的组合，光标所在字符向后查找至ch删除之间内容并进入插入模式 :1,$ s/word1/word2 将全文每行第一个word1替换成word2 :1,$ s/word1/word2/g 将全文所有word1替换成word2 6. 文本复制、剪切和粘贴 操作 说明 yl 复制光标所在字符，前面可接数字表多个 x/dl 剪切光标所在字符，前面可接数字表多个　注：X剪切前一个字符 yw/dw 复制/剪切光标后的一个单词，前面可加数字表多个 yy/dd 复制/剪切光标所在行，前面可加数字表向后多行 :2 copy/move 15 复制/剪切第二行内容到第十五行之后 :1,6 copy/move 15 复制/剪切第一行到第六行内容到第十五行之后 p 粘贴到光标下一行 P 粘贴到光标上一行 7. 重复与撤销 操作 说明 . 重复执行上一条指令 u 撤销上一个操作 U 撤销在当前行上的所有修改 8. 更改vim编辑器设置 操作 说明 :set [no]nu/number [不]显示行号 :set [no]ai/autoindent [不]设置自动缩进 :set showmode/noshowmode 显示/关闭当前编辑状态 :set [no]ic/ignorecase 搜索时[不]忽略大小写 :set list/nolist 显示/隐藏特殊字符 :set [no]sm/showmath [不]开启特殊字符匹配，如括号 :set wm/wrapmargin=n 设置输入长文本距离右边界多少时换行 :set all 查看所有设置值 编辑器的默认配置文件：在当前用户主目录(~)下创建一个.vimrc文件进行配置\nneovim 使用sudo保存文件：:w !sed '1i password' | sudo -S tee % \u0026gt;/dev/null\n13. Shell编程(教程,shell字符串) 1. Shell变量 1. 变量类别 本地变量(局部变量)：也称为用户自定义变量，是在当前shell环境，当前进程内有效的变量，一般在脚本或命令中定义 环境变量：相当于全局变量，也称为系统变量。它与本地变量的差别在于它可以用于所有用户进程，和windows系统的环境变量类似 预定义变量：也称shell变量，相当于C语言中主函数变量，执行脚本程序时就被认定且不再改变 2. 常见预定义变量 特殊变量名 说明 $# 存储shell程序中命令行参数的个数 $? 存储shell中上一个程序执行的返回值(0表示命令执行成功，非0表示出错) $[1-n] 存储第[1-n]个命令行参数 $0 存储shell程序自己的名称 $* 存储shell脚本的所有参数(不包括$0) $$ 存储shell脚本的进程号(pid) 3. read命令 语法：\nread [-ers] [-a aname] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name ...] -a 后跟一个变量，该变量会被认为是个数组，然后给其赋值，默认是以空格为分割符。 -d 后面跟一个标志符，其实只有其后的第一个字符有用，作为结束的标志。 -p 后面跟提示信息，即在输入前打印提示信息。 -e 在输入的时候可以使用命令补全功能。 -n 后跟一个数字，定义输入文本的长度，很实用。 -r 屏蔽\\，如果没有该选项，则\\作为一个转义字符，有的话 \\就是个正常的字符了。 -s 安静模式，在输入字符时不再屏幕上显示，例如login时输入密码。 -t 后面跟秒数，定义输入字符的等待时间。 -u 后面跟fd，从文件描述符中读入，该文件描述符可以是exec新开启的。 2. 选择结构 1. 条件判断式：test 文件存在性测试：\n参数 说明 -e 文件是否存在 -f 文件是否存在且为文件(file) -d 文件是否存在且为目录(directory) -b 文件是否存在且为一个block device文件 -c 文件是否存在且为一个character device文件 -S 文件是否存在且为一个Socket文件 -p 文件是否存在且为一个FIFO(pipe)文件 -L 文件是否存在且为一个链接文件 例：test -e file\n若当前目录下存在文件file，返回值为真，否则为假\n文件的权限测试：\n参数 说明 -r 检测该文件是否存在且具有可读的权限 -w 检测文件是否存在且具有可写的权限 -x 检测文件是否存在且具有可运行的权限 -u 检测文件是否存在且具有SUID的属性 -g 检测文件是否存在且具有SGID的属性 -k 检测文件是右存在且具有Sticky bit的属性 -s 检测文件是否存在且为非空白文件 例：test -r file\n若当前目录下文件file可读，返回值为真，否则为假 文件的新旧测试：\n参数 说明 -nt 判断两个文件到底哪一个文件要新 -ot 判断两个文件哪个文件要旧 -ef 判断两个文件是否为同一文件， 可用于判断硬链接文件 数值大小测试：\n参数 说明 -eq 测试两数值是否相等(equal) -ne 测试两数值是否不等(not equal) -gt 测试前一个数值n1是否大于后一个数值n2(greater than) -lt 测试n1是否小于n2(less than) -ge 测试n1是否大于等于n2(greater than or equal) -le 测试n1是否小于等于n2(less than or equal) 例：test n1 -eq n2\n若数值n1与n2相等，返回值为真，否则为假\n字符串测试\n参数 说明 -z 用于测试字符串长度是否为0，若字符串为空，则返回true -n 用于测试字符串长度是否为非0，若字符串为非空，则返回true = 用于判断两个字符串是否相等，苦相等则返回true != 用于判断两个字符串是否不相等，若不相等，则返回true 例：\ntest -z string: 测试string是否为空 test str1 = str2: 测试str1与str2是否相等\n注：\u0026rsquo; = \u0026lsquo;与 \u0026rsquo; != \u0026lsquo;两边要加空格 多重条件判定\n参数 说明 -a 两种情况同时成立时才回传true(and) -o 两种情况任何一个成立就可回传true(or) ! 状态取反 例：\ntest -r file -a -x file: 表示file同时具有r与x权限时才回传true test ! -x file: 表示file不具有x权限时，回传true 综合例：\n使用者输入一个文件名，程序判断：\n这个文件是否存在，左路不存在则给予一个Filename does not exist的信息，并中断程序 若这个文件存在，则判断它是文件还是目录，结果输出Filename is regular file或Filename is directory 判断当前用户对这个设施或目录所拥有的权限，并输出权限信息 程序：\n:\u0026lt;\u0026lt;! 让使用者输入文件名，并且判断使用者是否真的有输入字符串 ! echo -e \u0026#34;Please input a filename, I will check the filename\u0026#39;s type and permission. \\n\\n\u0026#34; read -p \u0026#34;Input a filename : \u0026#34; filename test -z $filename \u0026amp;\u0026amp; echo \u0026#34;You MUST input a filename.\u0026#34; \u0026amp;\u0026amp; exit 0 # 判断文件是否存在？若不存在则显示信息并结束脚本 test ! -e $filename \u0026amp;\u0026amp; echo \u0026#34;The filename \u0026#39;$filename\u0026#39; DO NOT exist\u0026#34; \u0026amp;\u0026amp; exit 0 # 开始判断文件类型与属性 test -f $filename \u0026amp;\u0026amp; filetype=\u0026#34;regulare file\u0026#34; test -d $filename \u0026amp;\u0026amp; filetype=\u0026#34;directory\u0026#34; test -r $filename \u0026amp;\u0026amp; perm=\u0026#34;readable\u0026#34; test -w $filename \u0026amp;\u0026amp; perm=\u0026#34;$perm writable\u0026#34; test -x $filename \u0026amp;\u0026amp; perm=\u0026#34;$perm executable\u0026#34; # 开始输入 echo \u0026#34;The filename: $filename is a $filetype\u0026#34; echo \u0026#34;And the permissions are : $perm\u0026#34; 2. 条件判断符：[] 说明：\n能实现和test命令一样的功能 为了与通配符区分，各元素间均有空格 例：\n[ 1 -eq 2 ]: 判断1与2是否相等(注意[,]与内容间有空格)\n3. if-else 用法：\nif [ 条件判断式1 ]; then # 可以把then写在下一行，就不用写; 语句1 elif [ 条件判断式2 ]; then 语句2 else 语句3 fi 例：\nnum1=100 # 等号两边不能有空格 num2=100 if [ $num1 -eq $num2 ] then echo \u0026#39;两个数相等！\u0026#39; else echo \u0026#39;两个数不相等！\u0026#39; fi 4. case case \u0026lt;变量\u0026gt; in \u0026lt;字符串1\u0026gt; ) {\u0026lt;命令清单1\u0026gt;};; ... \u0026lt;字符串n\u0026gt; ) {\u0026lt;命令清单n\u0026gt;};; *) {其他命令};; esac 例：写一个shell脚本命名为capital，要求运行程序时输入国家名字，程序能输出这个国家的首都\n#!/bin/bash case $1 in China) echo Beijing;; # 注意是两个;相当于break USA) echo Washington;; British) echo London;; Russia) echo Moskow;; *)echo Out of my knowledge;; esac 3. 循环结构 1. for循环语句 语法一：\nfor((变量赋值;条件判断;变量迭代)) do 语句块 done 注意：for语句中一定要以do开始及以done结尾\n例：编写一个for循环，输入0-4共5个数值\n#!/bin/bash #第一行表示用bash执行 for((i=0;i\u0026lt;5;i++)) do echo $i, is a number done 语法二\nfor var in item1 itme2 ... itemN do 语句块 done 例1：编写一个for循环，变量的取值列表为：dog cat lion tiger，输出结果\n#!/bin/bash for animal in dog cat lion tiger do echo “There are ${animal}s.” done 例2：\n#!/bin/bash list=\u0026#34;beijing tianjing shanghai guangzhou\u0026#34; list=$list\u0026#34; xizang\u0026#34; for scenery in $list do echo “Have you visited $scenery?” done :\u0026lt;\u0026lt;! 输出： Have you visited beijing? Have you visited tianjing? Have you visited shanghai? Have you visited guangzhou? Have you visited xizang? ! 注：若列表对象中有空格，可以用\u0026quot;\u0026ldquo;包含\n2. while循环语句 语法：\nwhile [条件判断式] do 语句块 done 注：当条件判断式成立时，执行循环，while后面没有:\n例：\n当用户输入break或者BREAK才结束程序执行，否则就一直告知用户输入字符串，并将用户输入字符串输出\n#!/bin/bash while [ \u0026#34;$yn\u0026#34; != “break\u0026#34; -a \u0026#34;$yn\u0026#34; != “BREAK\u0026#34; ] do read -p “Please input a string : (break/Break to stop) \u0026#34; yn echo You input a string : $yn done echo \u0026#34;OK! you interrupt the program.\u0026#34; 14. 文档编辑 1. sed命令(其它教程) sed命令(其它教程)\n特点：\n从文件中读入一行数据并把它保存在临时缓冲区中 处理临时缓冲区的内容，并将处理结果发送到显示器上 逐行处理文件所有内容直到最后一行 语法：\nsed [-hnV][-e\u0026lt;script\u0026gt;][-f\u0026lt;script文件\u0026gt;][文本文件] 选项\n选项 说明 -n 仅显示script处理后的结果 -e\u0026lt;script\u0026gt; 以选项中指定的script来处理输入的文本文件(默认) -f\u0026lt;script文件\u0026gt; 以选项中指定的script文件来处理输入的文本文件 -r/-E sed使用扩展正则表达式 -i 直接修改文档读取的内容，不在屏幕上输出 script\n地址定位：\n例：\n将第三行的A替换为you：sed '3s/A/you/g' file 将奇数行的A替换为you：sed '1~2 s/A/you/g' file 将第1行(含)和第2行(含)之间的A替换为you：sed '1,2s/A/you/g' file 将第1行和之后4行之间的A替换为you：sed '1,+4s/A/you/g' file 将文件的A替换为you：sed 's/A/you/g' file 和正则表达式搭配使用，将行首为#号的行中A替换为you：sed '/^#/ s/A/you/g' file 编辑命令：\n选项 说明 a 在指定行后面追加文本；支持使用\\n实现多行追加 i 在指定行前面插入文本 d 删除匹配的行 s 替换字符串 c 替换匹配行 例：\n在文件file中第一行后加两行：sed '1a aa\\naa' file 删除第一行：sed '1d' file 将第一行的A替换为you：sed '1s/A/you/g' file 将第一行替换为hello,world: sed '1c hello,world' file 将每一行后面加上.mp4并为每一行两端添加单引号：sed \u0026quot;s/$/.mp4/;s/.*/'\u0026amp;'/\u0026quot; file 正则表达式说明\nsed中使用正则表达式使用**//**包涵，其中上例中sed '3s/A/you/g' file中A与you就是正则表达式，即先在匹配的行中找到\u0026rsquo;A\u0026rsquo;然后用\u0026rsquo;you\u0026rsquo;替换，例如：\n​ 将第三行的A后面加上一个B：sed '3s/A/\u0026amp;B/g' file或sed '3s/\\(A\\)/\\1B/g' file\n说明\n其中对于\u0026rsquo;\u0026amp;\u0026lsquo;代表匹配结果，\u0026lsquo;1\u0026rsquo;代表匹配结果的第一个分组； 对于第二种写法，若不想对特殊符号转义\u0026rsquo;\\\u0026lsquo;可以使用\u0026rsquo;-r\u0026rsquo;选项，然后改写为：\nsed -r '3s/(A)/\\1B/g' file 2. awk命令 命令语法：\nawk 'BEGIN{ commands } pattern{ commands } END{ commands }' file\nawk命令运行过程\n通过关键字BEGIN执行BEGIN后花括号{}后的内容 pattern部分匹配成功后，依次对该行执行pattern后花括号后的内容，循环读取文件直到文件结束。\n开始 END 块执行，END 块可以输出最终结果。 选项\n选项 说明 -f file 从脚本文件中读取awk命令 -v var=value 赋值一个用户定义变量 -F fs 指定输入文件分隔符(改变变量FS的值)，fs是一个字符串或者正则表达式 内建变量\n变量 说明 $n 当前记录的第n个字段，字段间由FS分隔 $0 完整的输入记录 ARGC 命令行参数的数目 ARGIND 命令行中当前文件的位置(从0开始算) ARGV 包含命令行参数的数组 CONVFMT 数字转换格式(默认值为%.6g)ENVIRON环境变量关联数组 ERRNO 最后一个系统错误的描述 FIELDWIDTHS 字段宽度列表(用空格键分隔) FILENAME 当前文件名 FNR 各文件分别计数的行号 FS 字段分隔符(默认是任何空格) IGNORECASE 如果为真，则进行忽略大小写的匹配 NF 一条记录的字段的数目 NR 已经读出的记录数，就是行号，从1开始 OFMT 数字的输出格式(默认值是%.6g) OFS 输出字段分隔符，默认值与输入字段分隔符一致。 ORS 输出记录分隔符(默认值是一个换行符) RLENGTH 由match函数所匹配的字符串的长度 RS 记录分隔符(默认是一个换行符) RSTART 由match函数所匹配的字符串的第一个位置 SUBSEP 数组下标分隔符(默认值是/034) 例：\nMike Harrington:[510] 548-1278:250:100:175\nChristian Dobbins:[408] 538-2358:155:90:2\n01Susan Dalsass:[206] 654-6279:250:60:50\nArchie McNichol:[206] 548-1348:250:100:175\nJody Savage:[206] 548-1278:15:188:150\nGuy Quigley:[916] 343-6410:250:100:175\nDan Savage:[406] 298-7744:450:300:275\nNancy McNeil:[206] 548-1278:250:80:75\nJohn Goldenrod:[916] 348-4278:250:100:175\nChet Main:[510] 548-5258:50:95:135\nTom Savage:[408] 926-3456:250:168:200\nElizabeth Stachelin:[916] 440-1763:175:75:300\n显示所有电话号码：awk -F: '{print $2}' awk_exercise 显示Susan的姓名和电话号码：awk -F[:\\ ] '$1==\u0026quot;Susan\u0026quot;{print $1,$2\u0026quot;:\u0026quot;$3,$4}' awk_exercise 显示Mike的总捐款：awk -F[:\\ ] '$1==\u0026quot;Mike\u0026quot;{print $5+$6+$7}' awk_exercise 显示Savage的全名和电话号码：awk -F: '$1~/Savage/{print $1\u0026quot;:\u0026quot;$2}' awk_exercise 15. shell快捷键 编辑命令 Ctrl + a ：移到命令行首 Ctrl + e ：移到命令行尾 Ctrl + f ：按字符前移（右向） Ctrl + b ：按字符后移（左向） Alt + f ：按单词前移（右向） Alt + b ：按单词后移（左向） Ctrl + xx：在命令行首和光标之间移动 Ctrl + u ：从光标处删除至命令行首 Ctrl + k ：从光标处删除至命令行尾 Ctrl + w ：从光标处删除至字首 Alt + d ：从光标处删除至字尾 Ctrl + d ：删除光标处的字符 Ctrl + h ：删除光标前的字符 Ctrl + y ：粘贴至光标后 Alt + c ：从光标处更改为首字母大写的单词 Alt + u ：从光标处更改为全部大写的单词 Alt + l ：从光标处更改为全部小写的单词 Ctrl + t ：交换光标处和之前的字符 Alt + t ：交换光标处和之前的单词 Alt + Backspace：与 Ctrl + w 相同类似，分隔符有些差别 重新执行命令 Ctrl + r：逆向搜索命令历史 Ctrl + g：从历史搜索模式退出 Ctrl + p：历史中的上一条命令 Ctrl + n：历史中的下一条命令 Alt + .：使用上一条命令的最后一个参数 控制命令 Ctrl + l：清屏 Ctrl + o：执行当前命令，并选择上一条命令 Ctrl + s：阻止屏幕输出 Ctrl + q：允许屏幕输出 Ctrl + c：终止命令 Ctrl + z：挂起命令 Bang (!) 命令 !!：执行上一条命令 !blah：执行最近的以 blah 开头的命令，如 !ls !blah:p：仅打印输出，而不执行 !$：上一条命令的最后一个参数，与 Alt + . 相同 !$:p：打印输出 !$ 的内容 !*：上一条命令的所有参数 !:p：打印输出 ! 的内容 ^blah：删除上一条命令中的 blah ^blah^foo：将上一条命令中的 blah 替换为 foo ^blah^foo^：将上一条命令中所有的 blah 都替换为 foo ","permalink":"http://yysog.com/posts/linux%E7%AC%94%E8%AE%B0/","summary":"\u003ch1 id=\"linux笔记\"\u003elinux笔记\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.runoob.com/linux/linux-tutorial.html\"\u003eLinux 教程 | 菜鸟教程 (runoob.com)\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"1-字符图形界面\"\u003e1. 字符/图形界面\u003c/h2\u003e\n\u003ch3 id=\"1-字符图形界面的切换\"\u003e1. 字符/图形界面的切换\u003c/h3\u003e\n\u003cp\u003e计算机启动后默认进入图形界面登陆，若在进入字符界面，在图形登录界面使用Ctrl+Alt+F3;\u003cbr\u003e\n若需从字符界面返回图形界面，使用Ctrl+Alt+F1\u003c/p\u003e\n\u003ch3 id=\"2-查看修改默认登陆界面\"\u003e2. 查看/修改默认登陆界面\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e查看默认登陆界面：\u003ccode\u003esystemctl get-default\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e修改默认登陆界面：\u003ccode\u003esudo systemctl set-default [登陆状态]\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e登陆状态：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003egraphical.target\u003c/code\u003e 表示图形界面\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003emulti-user.target\u003c/code\u003e 表示字符界面\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"3-字符界面关闭和重启需要root权限\"\u003e3. 字符界面关闭和重启(需要root权限)\u003c/h3\u003e\n\u003ch4 id=\"1-shutdownhttpswwwrunoobcomlinuxlinux-comm-shutdownhtml\"\u003e1. \u003ca href=\"https://www.runoob.com/linux/linux-comm-shutdown.html\"\u003eshutdown\u003c/a\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e命令格式：\u003ccode\u003eshutdown [选项] [时间] [警告信息]\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e最常用： \u003ccode\u003e$ sudo shutdown(一分钟后关机)\u003c/code\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth style=\"text-align: center\"\u003e选项\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003e选项含义\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e-k\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e并不会关机，只发出警告信息给所有用户\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e-r\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e重新启动系统\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e-h\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e关闭系统\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e-c\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e取消运行shutdown\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e例：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e发出关机警告信息，并不会关机：\u003ccode\u003e$sudo shutdown -k\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e立即关机：\u003ccode\u003e$sudo shutdown –h now\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e45分钟后关闭计算机：\u003ccode\u003e$sudo shutdown –h +45\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e重启计算机并发出警告：\u003ccode\u003e$sudo shutdown –r now \u0026quot;system will be reboot now.\u0026quot;\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e定时在1点38分重启计算机：\u003ccode\u003e$sudo shutdown –r 01:38\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"2-halthttpswwwrunoobcomlinuxlinux-comm-halthtml\"\u003e2. \u003ca href=\"https://www.runoob.com/linux/linux-comm-halt.html\"\u003ehalt\u003c/a\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e命令格式：\u003ccode\u003ehalt [选项]\u003c/code\u003e\u003c/p\u003e","title":"linux笔记"},{"content":"最近想把之前写的markdown笔记部署起来搭个博客，主要有下面两方面考虑：\n便于多端访问：之前都用smb共享，但在移动端体验一般。 便于格式的统一 考虑到之后可能会将之些笔记部署的云上或github上，为了方便迁移，选择静态博客生成工具hugo.大多数教程的部署方案都是使用github action，但考虑到github正常访问速度等问题，故pass。\n由于手头有一台闲置的笔记本，目前用来当一个简单的服务器用，像一些smb，alist，ql等乱七八糟的内容都挂在上面。现在想把博客也挂上去，主要在局域网内访问，在外面需要的话也可以用内网穿透服务临时用一下。\n需求 移植性好，以便日后可能的平台迁移(静态生成工具移植都方便) 尽量降低对markdown编写侵入，编写完后自动化构建 可以在不同应用编辑Markdown文档(主要是图片路径问题) 方案 自动化构建思路主要就两种：\nhugo server + nginx反向代理 inotifywait + 脚本 最开始本想通过直接通过第一种来实现。但后来发现有些应用(obsidian，还无法关闭)在写markdown的时候会自动保存文档，而且频率相当高。这就导致用hugo server后需要经常性的编译写好的文档，对性能影响较大，没办法就只能用inotifywait写脚本监听文件变化了。\n流程如下：\n创建一个文件deploy.md，用于inofitywait监控 当编写完markdown后，能过修改文件deploy.md触发事件 inotiywait收到事件后执行脚本编译，并将编译后的文件同步到nginx 具体过程 使用inofitywait先安装inotify-tools包：\nsudo pacman -S inotify-tools\n对于文件deploy.md，并没有啥要求。之所有选择md文件，主要是由于大部分markdown软件默认只显示md文件。inofitywait选择监控close_write事件，当想要发布内容时只需要随便改动一下文件保存即可。\n推荐放一个复选框- [ ] trigger\n监测deploy.md事件脚本(deployer.sh)：\n#!/bin/bash flagPath=\u0026#34;/path/to/you/deploy.md\u0026#34; # 参考：${HOME}/share/hugo/deploy.md deployerPath=\u0026#34;/path/to/your/hugo/site\u0026#34; # 参考：${HOME}/projects/hugo/blog nginxPath=\u0026#34;/path/to/your/nginx/html/\u0026#34; # 参考: ${HOME}/projects/docker/nginx/html/ sleepTime=10 # 触发构建后10s之后才能再次构建 while true; do file=$(inotifywait -qe \u0026#39;close_write\u0026#39; $flagPath | if read file; then echo $file fi) # 监听close_write事件，即以可写模式打开后关闭触发 hugo --quiet --cleanDestinationDir -s $deployerPath \u0026amp;\u0026amp; rsync --delete -a \u0026#34;${deployerPath}/public/\u0026#34; $nginxPath # 编译并将public同步到nginx的html下 if [ $? -eq 0 ]; then echo \u0026#34;Successfully deployed $deployerPath to $nginxPath fi sleep $sleepTime done systemd单元文件blog-deployer.service\n注意替换\u0026lt;\u0026gt;中内容\n[Unit] Description=Deployer blog to nginx after md file changed After=network-online.target [Service] Type=simple User=\u0026lt;you\u0026gt; Group=\u0026lt;yourgourp\u0026gt; ExecStart=\u0026lt;/path/to/you\u0026gt;/deployer.sh Restart=on-failure StandardOutput=syslog StandardError=syslog [Install] WantedBy=multi-user.target 启动服务\nsudo ln -s ${PWD}/blog-deployer.service /usr/lib/systemd/system/blog-deployer.service sudo systemctl daemon-reload \u0026amp;\u0026amp; sudo systemctl enable --now blog-deployer 关于hugo的图片路径问题 markdown的图片管理一直是一个麻烦的问题。如果将放本地，如果想迁移文件或发表到其它平台时也需要将文档内图片一起带上，这种情况放云上通过链接访问毫无疑问是一个更好的选择。但这也意味着需要一笔费用来购买对应的服务或服务器，而且在没网络的情况下图片是无法加载的，对我来说放在本地就可以了。\n放本地会遇到的问题就是hugo图片路径和markdown对不上的问题。这时候一个解决文案就是能过hugo的联合文件系统\n只需要将下面的内容放到hugo的config.yaml中\n我的obsidian文件夹在${HOME}/share/hugo，yaml文件在${HOME}/projects/hugo/blog/config.yaml\nmodule: mounts: - source: content target: content - source: /home/yysog/share/typora/hugo/content target: content - source: static target: static - source: /home/yysog/share/typora/hugo/img target: static/img 并使用相对路径下访问图片，在obsidian中可以打开基于当前笔记的相对路径(typora也有类似设置)\n然后下载插件Custom Attachment Location，并设置如下\n我的obsidian仓库结构如下：\nmd文件放在content下，图像会自动放在img下。之后要迁移只需找到对应文件名开头的图片进行复制就行，这样无论是在markdown软件还是博客中打开，图片都能正确加载。\n","permalink":"http://yysog.com/posts/hugo+nginx%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2/","summary":"\u003cp\u003e最近想把之前写的markdown笔记部署起来搭个博客，主要有下面两方面考虑：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e便于多端访问：之前都用smb共享，但在移动端体验一般。\u003c/li\u003e\n\u003cli\u003e便于格式的统一\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e考虑到之后可能会将之些笔记部署的云上或github上，为了方便迁移，选择静态博客生成工具\u003ca href=\"https://gohugo.io/\"\u003ehugo\u003c/a\u003e.大多数教程的部署方案都是使用github action，但考虑到github正常访问速度等问题，故pass。\u003c/p\u003e\n\u003cp\u003e由于手头有一台闲置的笔记本，目前用来当一个简单的服务器用，像一些smb，alist，ql等乱七八糟的内容都挂在上面。现在想把博客也挂上去，主要在局域网内访问，在外面需要的话也可以用内网穿透服务临时用一下。\u003c/p\u003e\n\u003ch2 id=\"需求\"\u003e需求\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e移植性好，以便日后可能的平台迁移(静态生成工具移植都方便)\u003c/li\u003e\n\u003cli\u003e尽量降低对markdown编写侵入，编写完后自动化构建\u003c/li\u003e\n\u003cli\u003e可以在不同应用编辑Markdown文档(主要是图片路径问题)\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"方案\"\u003e方案\u003c/h2\u003e\n\u003cp\u003e自动化构建思路主要就两种：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ehugo server + nginx反向代理\u003c/li\u003e\n\u003cli\u003einotifywait + 脚本\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e最开始本想通过直接通过第一种来实现。但后来发现有些应用(obsidian，还\u003ca href=\"https://forum.obsidian.md/t/disable-auto-save-or-change-frequency/14230/35\"\u003e无法关闭\u003c/a\u003e)在写markdown的时候会自动保存文档，而且频率相当高。这就导致用hugo server后需要经常性的编译写好的文档，对性能影响较大，没办法就只能用inotifywait写脚本监听文件变化了。\u003c/p\u003e\n\u003cp\u003e流程如下：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e创建一个文件deploy.md，用于inofitywait监控\u003c/li\u003e\n\u003cli\u003e当编写完markdown后，能过修改文件deploy.md触发事件\u003c/li\u003e\n\u003cli\u003einotiywait收到事件后执行脚本编译，并将编译后的文件同步到nginx\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"具体过程\"\u003e具体过程\u003c/h3\u003e\n\u003cp\u003e使用\u003ca href=\"https://man.archlinux.org/man/inotifywait.1\"\u003einofitywait\u003c/a\u003e先安装\u003ccode\u003einotify-tools\u003c/code\u003e包：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003esudo pacman -S inotify-tools\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e对于文件deploy.md，并没有啥要求。之所有选择md文件，主要是由于大部分markdown软件默认只显示md文件。inofitywait选择监控close_write事件，当想要发布内容时只需要随便改动一下文件保存即可。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e推荐放一个复选框\u003ccode\u003e- [ ] trigger\u003c/code\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e监测deploy.md事件脚本(deployer.sh)：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#!/bin/bash\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e\u003c/span\u003e\u003cspan class=\"nv\"\u003eflagPath\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;/path/to/you/deploy.md\u0026#34;\u003c/span\u003e   \u003cspan class=\"c1\"\u003e# 参考：${HOME}/share/hugo/deploy.md\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003edeployerPath\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;/path/to/your/hugo/site\u0026#34;\u003c/span\u003e   \u003cspan class=\"c1\"\u003e# 参考：${HOME}/projects/hugo/blog\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003enginxPath\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;/path/to/your/nginx/html/\u0026#34;\u003c/span\u003e  \u003cspan class=\"c1\"\u003e# 参考: ${HOME}/projects/docker/nginx/html/\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003esleepTime\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"m\"\u003e10\u003c/span\u003e    \u003cspan class=\"c1\"\u003e# 触发构建后10s之后才能再次构建\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003ewhile\u003c/span\u003e true\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"k\"\u003edo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"nv\"\u003efile\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"k\"\u003e$(\u003c/span\u003einotifywait -qe \u003cspan class=\"s1\"\u003e\u0026#39;close_write\u0026#39;\u003c/span\u003e \u003cspan class=\"nv\"\u003e$flagPath\u003c/span\u003e \u003cspan class=\"p\"\u003e|\u003c/span\u003e \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"nb\"\u003eread\u003c/span\u003e file\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"k\"\u003ethen\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"nb\"\u003eecho\u003c/span\u003e \u003cspan class=\"nv\"\u003e$file\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003efi)\u003c/span\u003e       \u003cspan class=\"c1\"\u003e# 监听close_write事件，即以可写模式打开后关闭触发\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        hugo --quiet --cleanDestinationDir -s \u003cspan class=\"nv\"\u003e$deployerPath\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e rsync --delete -a \u003cspan class=\"s2\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"si\"\u003e${\u003c/span\u003e\u003cspan class=\"nv\"\u003edeployerPath\u003c/span\u003e\u003cspan class=\"si\"\u003e}\u003c/span\u003e\u003cspan class=\"s2\"\u003e/public/\u0026#34;\u003c/span\u003e \u003cspan class=\"nv\"\u003e$nginxPath\u003c/span\u003e \u003cspan class=\"c1\"\u003e# 编译并将public同步到nginx的html下\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"o\"\u003e[\u003c/span\u003e \u003cspan class=\"nv\"\u003e$?\u003c/span\u003e -eq \u003cspan class=\"m\"\u003e0\u003c/span\u003e \u003cspan class=\"o\"\u003e]\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"k\"\u003ethen\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"nb\"\u003eecho\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;Successfully deployed \u003c/span\u003e\u003cspan class=\"nv\"\u003e$deployerPath\u003c/span\u003e\u003cspan class=\"s2\"\u003e to \u003c/span\u003e\u003cspan class=\"nv\"\u003e$nginxPath\u003c/span\u003e\u003cspan class=\"s2\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s2\"\u003e        fi\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s2\"\u003e        sleep \u003c/span\u003e\u003cspan class=\"nv\"\u003e$sleepTime\u003c/span\u003e\u003cspan class=\"s2\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s2\"\u003edone\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003esystemd单元文件blog-deployer.service\u003c/p\u003e","title":"hugo+Nginx本地部署"}]